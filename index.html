<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="#FF9FF3" />

    <title>Slide-o-Matic - Presentation Maker</title>
    <meta
      name="description"
      content="Create beautiful, dynamic presentations with ease. Slide-o-Matic is a modern, web-based slide deck builder that gets out of your way."
    />
    <link rel="canonical" href="https://slideomatic.app/" />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://slideomatic.app/" />
    <meta property="og:title" content="Slide-o-Matic - Presentation Maker" />
    <meta property="og:description" content="Create beautiful, dynamic presentations with ease. Slide-o-Matic is a modern, web-based slide deck builder that gets out of your way." />
    <meta property="og:image" content="https://slideomatic.app/og-image.jpg" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:image:alt" content="Slide-o-Matic Interface" />

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:url" content="https://slideomatic.app/" />
    <meta name="twitter:title" content="Slide-o-Matic - Presentation Maker" />
    <meta name="twitter:description" content="Create beautiful, dynamic presentations with ease. Slide-o-Matic is a modern, web-based slide deck builder that gets out of your way." />
    <meta name="twitter:image" content="https://slideomatic.app/og-image.jpg" />
    <meta name="twitter:image:alt" content="Slide-o-Matic Interface" />

    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üé¨</text></svg>" />

    <link rel="stylesheet" href="css/landing.css" />
    <link rel="stylesheet" href="css/drawers.css" />
    <link rel="stylesheet" href="css/accordion.css" />
    <link rel="stylesheet" href="css/custom-select.css" />
    <link rel="stylesheet" href="css/print.css" />
  </head>
  <body>
    <main class="landing">
      <!-- ===== HERO SECTION: Combined H1 + CTAs ===== -->
      <section class="landing__hero">
        <div class="landing__intro">
          <p class="landing__eyebrow">Slide builder</p>
          <h1 class="landing__title landing__title--main">Slide-o-Matic</h1>
          <h2 class="landing__title landing__title--sub">Slideshows that don't suck</h2>
          <p class="landing__subtitle">
            Does the thing and gets out of the way.
          </p>
        </div>

        <div class="landing__cta-grid">
          <article class="cta-panel cta-panel--primary">
            <div class="cta-panel__header">
              <p class="cta-panel__eyebrow">First time?</p>
              <h3>See how it works</h3>
            </div>
            <p>Interactive guide shows you around. Keep building or start fresh.</p>
            <div class="cta-panel__actions">
              <button class="button button--primary" type="button" data-action="open-demo">Open guide deck</button>
            </div>
          </article>

          <article class="cta-panel cta-panel--secondary">
            <div class="cta-panel__header">
              <p class="cta-panel__eyebrow">Ready to go</p>
              <h3>Start blank</h3>
            </div>
            <p>Jump in. Press ? for shortcuts.</p>
            <div class="start-menu">
              <button class="button button--secondary" type="button" data-start-toggle aria-expanded="false">
                New deck
              </button>
              <div class="start-menu__list" data-start-menu hidden>
                <button type="button" data-new-mode="live">
                  <strong>Blank deck</strong>
                  <span>Start from scratch with full creative control</span>
                </button>
                <button type="button" data-new-mode="paste">
                  <strong>Paste JSON</strong>
                  <span>Got exported slides? Drop them in and keep editing</span>
                </button>
                <button type="button" data-new-mode="upload">
                  <strong>Upload JSON</strong>
                  <span>Import a deck file from your computer</span>
                </button>
              </div>
            </div>
            <input type="file" id="upload-input" accept=".json,application/json" style="display: none;" />
          </article>
        </div>
      </section>

      <!-- ===== FEATURES SECTION: Combined headline + cards ===== -->
      <section class="landing__features" id="about">
        <div class="landing__features-intro">
          <h2>Slide on ü§†</h2>
          <p>
            Sweet presentations lickety split
          </p>
        </div>

        <div class="landing__cards">
          <article class="landing__card">
            <div class="landing__card-icon">‚ö°</div>
            <h3>Quick</h3>
            <p>Heaps of layouts. Navigate with arrows, edit with <strong>E</strong>, themes with <strong>T</strong>.</p>
          </article>
          <article class="landing__card">
            <div class="landing__card-icon">üé®</div>
            <h3>Slick</h3>
            <p>Tons of themes plus random generators. Switch vibes anytime.</p>
          </article>
          <article class="landing__card">
            <div class="landing__card-icon">üíæ</div>
            <h3>Neat</h3>
            <p>Star your favorites. Export to share. Everything saves locally.</p>
          </article>
        </div>
      </section>

      <!-- ===== COLLECTION PROMO ===== -->
      <section class="collection-promo">
        <div class="collection-promo__content">
          <p class="collection-promo__eyebrow">Shared pack</p>
          <h2>Design Starter Pack</h2>
          <p>
            Free Design Resources plus the Brand &amp; Visual deck now live on one page. Open it, duplicate a deck, share the link‚Äîwhatever you need.
          </p>
        </div>
        <div class="collection-promo__actions">
          <a class="button button--secondary" href="collections.html?collection=design-starter-pack">Open the page</a>
        </div>
      </section>

      <!-- ===== YOUR DECKS: Simplified (moved to bottom) ===== -->
      <section class="deck-shelf" id="saved">
        <header class="deck-shelf__header">
          <div>
            <h2>Saved Decks</h2>
            <p class="deck-shelf__subtitle">Local decks stay on this device. The two default decks moved to <a href="collections.html?collection=design-starter-pack">this shared link</a>.</p>
          </div>
        </header>
        <ul class="deck-shelf__list" id="deck-shelf-list">
          <li class="deck-shelf__empty" id="deck-shelf-empty">
            <p>No decks yet</p>
            <p class="deck-shelf__empty-hint">Create your first deck above ‚Üë</p>
          </li>
        </ul>
      </section>
    </main>

    <div class="paste-modal" id="paste-modal" aria-hidden="true">
      <div class="paste-modal__backdrop" data-paste-cancel></div>
      <article class="paste-modal__dialog" role="dialog" aria-modal="true" aria-labelledby="paste-modal-title" tabindex="-1">
        <button class="paste-modal__close" type="button" aria-label="Close paste JSON modal" data-paste-cancel>√ó</button>
        <h2 class="paste-modal__title" id="paste-modal-title">Paste deck JSON</h2>
        <p class="paste-modal__subtitle">Paste an exported Slide-o-Matic JSON array or object and we'll boot the deck live.</p>
        <textarea id="paste-json-input" class="paste-modal__textarea" rows="10" spellcheck="false" placeholder='[{ "type": "title", ... }]'></textarea>
        <div class="paste-modal__actions">
          <button class="button button--primary" type="button" data-paste-submit>Load deck</button>
          <button class="link-button" type="button" data-paste-cancel>Cancel</button>
        </div>
      </article>
    </div>

    <footer class="landing__footer">
      <div class="landing__footer-about">
        <strong>About this thing</strong>
        <p>
          Built by <a href="mailto:bonesouprules@gmail.com">Pablo</a> in Brunswick, Melbourne.
        </p>
        <div class="landing__footer-buttons">
          <button class="link-button" type="button" data-about-open>More about this project</button>
          <a class="link-button link-button--kofi" href="https://ko-fi.com/pibulus" target="_blank" rel="noopener">‚òï Buy me a coffee</a>
        </div>
      </div>
      <div class="landing__footer-actions">
      </div>
    </footer>

    <div class="about-modal" id="about-modal" aria-hidden="true">
      <div class="about-modal__backdrop" data-about-close></div>
      <article class="about-modal__dialog" role="dialog" aria-modal="true" aria-labelledby="about-modal-title" tabindex="-1">
        <button class="about-modal__close" type="button" aria-label="Close about" data-about-close>√ó</button>
        <h2 class="about-modal__title" id="about-modal-title">About Slideomatic</h2>
        <p class="about-modal__lede">The Anti-PowerPoint. All flow. No friction.</p>

        <div class="about-modal__section">
          <h3>The Origin Story</h3>
          <p>This started during a late-night scramble to make a deck for my friend Cara's uni class. I opened the ‚Äúbig corporate apps‚Äù and immediately wanted to scream. Menus, alignment tools, bloat‚Äîlike flying a spaceship just to go to the grocery store.</p>
        </div>

        <div class="about-modal__section">
          <h3>The Philosophy</h3>
          <p>In a world of ‚ÄúWord,‚Äù we need more ‚ÄúNotepad.‚Äù Slideomatic is for getting ideas out of your head and onto the screen without fighting the software.</p>
        </div>

        <h3>The Goods</h3>
        <ul class="about-modal__list">
          <li>‚å®Ô∏è Keyboard Zen: stay mouse-free, press ? to see every shortcut.</li>
          <li>üé® Lush Themes: swap the vibe mid-deck‚Äîno formatting nightmares.</li>
          <li>üîí Local First: data lives on your device, no subscriptions, no tracking.</li>
          <li>üß† BYO Brain: drop in a free Gemini API key to unlock AI graphs and image prompts‚Äîyou own the key, you own the power.</li>
          <li>üì¶ JSON Native: export/share as JSON, open anywhere that speaks text.</li>
        </ul>

        <p class="about-modal__footer">
          Made by <a href="mailto:bonesouprules@gmail.com">Pablo</a>. Because making slides shouldn‚Äôt feel like a wrestling match.
        </p>
      </article>
    </div>

    <script type="module">
      import { safeParse, deriveDeckName } from './modules/utils.js';

      const DECK_STORAGE_PREFIX = 'slideomatic_deck_overrides:';
      const LAST_DECK_KEY = 'slideomatic:last-deck';

      const resumeButton = document.querySelector('[data-action="resume"]');
      const demoButton = document.querySelector('[data-action="open-demo"]');
      const startToggle = document.querySelector('[data-start-toggle]');
      const startMenu = document.querySelector('[data-start-menu]');
      const startButtons = document.querySelectorAll('[data-new-mode]');
      const uploadInput = document.getElementById('upload-input');
      const shelfList = document.getElementById('deck-shelf-list');
      const shelfEmpty = document.getElementById('deck-shelf-empty');
      const refreshShelfButton = document.querySelector('[data-action="refresh-shelf"]');
      const pasteModal = document.getElementById('paste-modal');
      const pasteDialog = pasteModal?.querySelector('.paste-modal__dialog');
      const pasteTextarea = document.getElementById('paste-json-input');
      const pasteSubmit = document.querySelector('[data-paste-submit]');
      const pasteClosers = document.querySelectorAll('[data-paste-cancel]');
      const actionButtons = document.querySelectorAll('[data-open-intent]');
      const aboutModal = document.getElementById('about-modal');
      const aboutDialog = aboutModal?.querySelector('.about-modal__dialog');
      const aboutOpeners = document.querySelectorAll('[data-about-open]');
      const aboutClosers = aboutModal?.querySelectorAll('[data-about-close]');

      const relativeTimeFormatter = typeof Intl !== 'undefined' && Intl.RelativeTimeFormat
        ? new Intl.RelativeTimeFormat(undefined, { numeric: 'auto' })
        : null;

      let aboutPreviousFocus = null;
      let pastePreviousFocus = null;
      let deckShelfCache = [];

      // Toast notification system
      let toastTimeout = null;
      function showToast(message, type = 'default') {
        // Remove any existing toast
        const existingToast = document.querySelector('.toast');
        if (existingToast) {
          existingToast.remove();
        }
        clearTimeout(toastTimeout);

        // Create new toast
        const toast = document.createElement('div');
        toast.className = `toast ${type === 'error' ? 'toast--error' : type === 'success' ? 'toast--success' : ''}`;
        toast.textContent = message;
        document.body.appendChild(toast);

        // Animate in
        requestAnimationFrame(() => {
          toast.classList.add('toast--visible');
        });

        // Auto-remove after 4 seconds
        toastTimeout = setTimeout(() => {
          toast.classList.remove('toast--visible');
          setTimeout(() => toast.remove(), 200);
        }, 4000);
      }

      console.log('[Index] ==================== INDEX.HTML INIT ====================');
      console.log('[Index] uploadInput element:', uploadInput);

      // Clean up old guide.json cache if it exists
      cleanupGuideCache();

      renderDeckShelf();
      bindStartMenu();
      bindNewDeckButtons();
      bindResumeButton();
      bindDemoButton();
      bindUploadInput();
      bindShelfRefresh();
      bindPasteModal();
      bindFooterActions();
      bindAboutModal();

      console.log('[Index] All bindings complete');
      console.log('[Index] =========================================================');

      function cleanupGuideCache() {
        try {
          const guideKey = `${DECK_STORAGE_PREFIX}guide.json`;
          if (localStorage.getItem(guideKey)) {
            localStorage.removeItem(guideKey);
            console.log('Cleaned up old guide.json cache');
          }
        } catch (error) {
          // Ignore cleanup errors
        }
      }

      function bindStartMenu() {
        if (!startToggle || !startMenu) return;
        startToggle.addEventListener('click', () => {
          const nextState = !startMenu.classList.contains('is-open');
          setStartMenuState(nextState);
        });

        document.addEventListener('click', (event) => {
          if (!startMenu.classList.contains('is-open')) return;
          if (startMenu.contains(event.target) || event.target === startToggle) return;
          setStartMenuState(false);
        });

        document.addEventListener('keydown', (event) => {
          if (event.key === 'Escape') {
            setStartMenuState(false);
          }
        });
      }

      function setStartMenuState(isOpen) {
        if (!startMenu || !startToggle) return;
        startMenu.hidden = !isOpen;
        startMenu.classList.toggle('is-open', isOpen);
        startToggle.setAttribute('aria-expanded', String(isOpen));
      }

      function bindNewDeckButtons() {
        startButtons.forEach((button) => {
          button.addEventListener('click', () => {
            setStartMenuState(false);
            handleNewDeckAction(button.dataset.newMode);
          });
        });
      }

      function handleNewDeckAction(mode) {
        console.log('[handleNewDeckAction] Mode:', mode);
        switch (mode) {
          case 'live':
            console.log('[handleNewDeckAction] Navigating to new blank deck');
            window.location.href = 'deck.html#deck=new&open=edit';
            break;
          case 'constructor':
            console.log('[handleNewDeckAction] Navigating to admin');
            window.location.href = 'admin.html';
            break;
          case 'paste':
            console.log('[handleNewDeckAction] Opening paste modal');
            openPasteModal();
            break;
          case 'upload':
            console.log('[handleNewDeckAction] Triggering file input click, uploadInput exists?', !!uploadInput);
            if (uploadInput) {
              console.log('[handleNewDeckAction] Calling uploadInput.click()');
              uploadInput.click();
            } else {
              console.error('[handleNewDeckAction] uploadInput is null/undefined!');
            }
            break;
          default:
            console.warn('[handleNewDeckAction] Unknown mode:', mode);
            break;
        }
      }

      function bindResumeButton() {
        if (!resumeButton) return;
        resumeButton.addEventListener('click', () => {
          const lastDeckId = getLastDeckId();
          if (lastDeckId) {
            openDeck(lastDeckId);
            return;
          }
          if (deckShelfCache.length > 0) {
            openDeck(deckShelfCache[0].id);
            return;
          }
          window.location.href = 'deck.html';
        });
      }

      function bindDemoButton() {
        demoButton?.addEventListener('click', () => {
          window.location.href = 'deck.html#slides=guide';
        });
      }

      function bindUploadInput() {
        console.log('[bindUploadInput] Called, uploadInput exists?', !!uploadInput);
        if (!uploadInput) {
          console.error('[bindUploadInput] uploadInput is null! Cannot bind listener');
          return;
        }
        console.log('[bindUploadInput] Binding change listener to input#upload-input');

        // Use both 'change' and 'input' events as fallback
        const handleFileSelect = (event) => {
          console.log('[Upload] ===== FILE SELECTION EVENT FIRED =====');
          console.log('[Upload] Event type:', event.type);
          const input = event.target;
          console.log('[Upload] Input element:', input);
          console.log('[Upload] Files:', input.files);
          const file = input.files?.[0];
          if (!file) {
            console.log('[Upload] No file selected, files.length:', input.files?.length);
            return;
          }
          console.log('[Upload] File selected:', file.name, 'Size:', file.size, 'bytes');

          const reader = new FileReader();
          reader.onload = () => {
            console.log('[Upload] File read complete, parsing JSON...');
            let parsed;
            try {
              parsed = JSON.parse(reader.result);
              console.log('[Upload] JSON parsed successfully');
            } catch (error) {
              console.error('[Upload] JSON parse error:', error);
              showToast('That file is not valid JSON. Try again.', 'error');
              input.value = '';
              return;
            }

            // Extract slides array from parsed data
            const slides = Array.isArray(parsed)
              ? parsed
              : Array.isArray(parsed?.slides)
              ? parsed.slides
              : null;

            if (!slides || slides.length === 0) {
              showToast('File must contain slides.', 'error');
              input.value = '';
              return;
            }

            // Generate a new deck ID and save to localStorage
            const deckId = generateDeckId();
            const key = buildDeckKey(deckId);
            const payload = {
              version: 1,
              updatedAt: Date.now(),
              source: `upload:${file.name}`,
              slides,
              meta: {
                name: deriveDeckName(slides),
                updatedAt: Date.now(),
                deckId: deckId
              }
            };

            console.log('[Upload] Generated deck ID:', deckId);
            console.log('[Upload] Storage key:', key);
            console.log('[Upload] Payload has', slides.length, 'slides');

            try {
              localStorage.setItem(key, JSON.stringify(payload));
              console.log('[Upload] Successfully saved to localStorage');

              // Verify it was saved
              const verification = localStorage.getItem(key);
              if (verification) {
                console.log('[Upload] Verification: deck exists in localStorage');
              } else {
                console.error('[Upload] Verification FAILED: deck not found after save!');
              }

              showToast(`Imported ${slides.length} slides`, 'success');
            } catch (error) {
              console.error('[Upload] Failed to save to localStorage:', error);
              showToast('Unable to save. Storage may be full.', 'error');
              input.value = '';
              return;
            }

            // Navigate to the new deck
            // Try using hash instead of query params to work with URL rewriting servers
            const targetUrl = `deck.html#deck=${encodeURIComponent(deckId)}&open=edit`;
            console.log('[Upload] Navigating to:', targetUrl);
            console.log('[Upload] Full URL will be:', new URL(targetUrl, window.location.href).toString());
            input.value = '';
            window.location.href = targetUrl;
          };

          reader.onerror = () => {
            showToast('Unable to read that file. Try again.', 'error');
            input.value = '';
          };

          reader.readAsText(file);
        };

        // Bind to change event (standard for file inputs)
        uploadInput.addEventListener('change', handleFileSelect);
        console.log('[bindUploadInput] Change listener bound to input#upload-input');
      }

      function bindShelfRefresh() {
        refreshShelfButton?.addEventListener('click', () => {
          renderDeckShelf();
        });
      }

      async function renderDeckShelf() {
        deckShelfCache = getSavedDecks();
        const allDecks = [...deckShelfCache];

        if (!shelfList) return;
        shelfList.querySelectorAll('.deck-card').forEach((node) => node.remove());

        if (shelfEmpty) {
          shelfEmpty.hidden = allDecks.length > 0;
        }

        allDecks.forEach((deck) => {
          shelfList.appendChild(createDeckCard(deck));
        });

        updateResumeButtonLabel();
      }

      function updateResumeButtonLabel() {
        if (!resumeButton) return;
        if (deckShelfCache.length === 0) {
          resumeButton.textContent = 'Resume deck';
          return;
        }
        const lastDeckId = getLastDeckId();
        const targetDeck = deckShelfCache.find((deck) => deck.id === lastDeckId) || deckShelfCache[0];
        resumeButton.textContent = `Resume ${targetDeck.name}`;
      }

      function createDeckCard(deck) {
        const item = document.createElement('li');
        item.className = 'deck-card';
        if (deck.starred) {
          item.classList.add('deck-card--starred');
        }
        if (deck.isBuiltIn) {
          item.classList.add('deck-card--builtin');
        }

        // Make entire card clickable to open deck
        item.style.cursor = 'pointer';
        item.addEventListener('click', () => openDeck(deck.id));

        const meta = document.createElement('div');
        meta.className = 'deck-card__meta';

        const nameRow = document.createElement('div');
        nameRow.className = 'deck-card__name-row';

        // Only show star button for user decks, not built-in
        if (!deck.isBuiltIn) {
          const starBtn = document.createElement('button');
          starBtn.type = 'button';
          starBtn.className = 'deck-card__star';
          starBtn.setAttribute('aria-label', deck.starred ? 'Remove from favorites' : 'Add to favorites');
          starBtn.textContent = deck.starred ? '‚òÖ' : '‚òÜ';
          starBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent card click
            toggleDeckStar(deck);
          });
          nameRow.append(starBtn);
        }

        const name = document.createElement('p');
        name.className = 'deck-card__name';
        name.textContent = deck.name;

        nameRow.append(name);

        const details = document.createElement('p');
        details.className = 'deck-card__details';
        if (deck.isBuiltIn) {
          details.textContent = '';
        } else {
          details.textContent = `${deck.slideCount} ${deck.slideCount === 1 ? 'slide' : 'slides'} ‚Ä¢ ${formatDeckTimestamp(deck.updatedAt)}`;
        }

        meta.append(nameRow, details);

        const actions = document.createElement('div');
        actions.className = 'deck-card__actions';

        // Only show rename/delete for user decks (no Open button needed since card is clickable)
        if (!deck.isBuiltIn) {
          const renameBtn = document.createElement('button');
          renameBtn.type = 'button';
          renameBtn.textContent = 'Rename';
          renameBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent card click
            renameDeck(deck);
          });

          const duplicateBtn = document.createElement('button');
          duplicateBtn.type = 'button';
          duplicateBtn.textContent = 'Duplicate';
          duplicateBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent card click
            duplicateDeck(deck);
          });

          const deleteBtn = document.createElement('button');
          deleteBtn.type = 'button';
          deleteBtn.textContent = 'Delete';
          deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent card click
            deleteDeck(deck);
          });

          actions.append(renameBtn, duplicateBtn, deleteBtn);
        }

        item.append(meta, actions);
        return item;
      }

      function formatDeckTimestamp(timestamp) {
        if (!timestamp) return 'Just now';
        const delta = Date.now() - timestamp;
        const minutes = 60 * 1000;
        const hours = 60 * minutes;
        const days = 24 * hours;

        if (relativeTimeFormatter) {
          if (delta >= days) {
            return relativeTimeFormatter.format(-Math.round(delta / days), 'day');
          }
          if (delta >= hours) {
            return relativeTimeFormatter.format(-Math.round(delta / hours), 'hour');
          }
          if (delta >= minutes) {
            return relativeTimeFormatter.format(-Math.round(delta / minutes), 'minute');
          }
          return 'Just now';
        }

        return new Date(timestamp).toLocaleString();
      }

      function getSavedDecks() {
        if (typeof localStorage === 'undefined') return [];
        const decks = [];
        for (let index = 0; index < localStorage.length; index += 1) {
          const key = localStorage.key(index);
          if (!key || !key.startsWith(DECK_STORAGE_PREFIX)) continue;
          const deckId = decodeURIComponent(key.slice(DECK_STORAGE_PREFIX.length));
          if (!deckId || !deckId.startsWith('deck-')) continue;
          const payload = safeParse(localStorage.getItem(key));
          if (!payload || !Array.isArray(payload.slides)) continue;
          const updatedAt = payload.meta?.updatedAt || payload.updatedAt || 0;
          const name = typeof payload.meta?.name === 'string' && payload.meta.name.trim()
            ? payload.meta.name.trim()
            : deriveDeckName(payload.slides);
          const starred = payload.meta?.starred === true;
          decks.push({
            id: deckId,
            name,
            updatedAt,
            slideCount: payload.slides.length,
            starred,
          });
        }
        // Sort: starred first, then by date
        return decks.sort((a, b) => {
          if (a.starred && !b.starred) return -1;
          if (!a.starred && b.starred) return 1;
          return (b.updatedAt || 0) - (a.updatedAt || 0);
        });
      }

      function renameDeck(deck) {
        if (!deck) return;
        const proposed = window.prompt('Name this deck', deck.name);
        if (!proposed) return;
        const name = proposed.trim();
        if (!name) return;
        const payload = getDeckPayload(deck.id);
        if (!payload) return;
        payload.meta = {
          ...(payload.meta || {}),
          name,
          updatedAt: Date.now(),
        };
        try {
          localStorage.setItem(buildDeckKey(deck.id), JSON.stringify(payload));
          renderDeckShelf();
          showToast('Deck renamed', 'success');
        } catch (error) {
          showToast('Unable to save. Storage may be full.', 'error');
        }
      }

      function duplicateDeck(deck) {
        if (!deck) return;
        const payload = getDeckPayload(deck.id);
        if (!payload) return;

        const newDeckId = generateDeckId();
        const newName = `Copy of ${deck.name}`;
        
        const newPayload = {
          ...payload,
          meta: {
            ...payload.meta,
            name: newName,
            updatedAt: Date.now(),
            deckId: newDeckId,
            starred: false // Don't copy starred status
          },
          updatedAt: Date.now(),
          source: `duplicate:${deck.id}`
        };

        try {
          localStorage.setItem(buildDeckKey(newDeckId), JSON.stringify(newPayload));
          renderDeckShelf();
          showToast('Deck duplicated', 'success');
        } catch (error) {
          showToast('Unable to duplicate deck. Storage may be full.', 'error');
        }
      }

      function deleteDeck(deck) {
        if (!deck) return;
        const confirmed = window.confirm(`Delete "${deck.name}" from this device?`);
        if (!confirmed) return;
        try {
          localStorage.removeItem(buildDeckKey(deck.id));
          if (getLastDeckId() === deck.id) {
            localStorage.removeItem(LAST_DECK_KEY);
          }
          renderDeckShelf();
          showToast('Deck deleted', 'success');
        } catch (error) {
          showToast('Unable to delete deck', 'error');
        }
      }

      function toggleDeckStar(deck) {
        if (!deck) return;
        const payload = getDeckPayload(deck.id);
        if (!payload) return;

        const newStarredState = !deck.starred;
        payload.meta = {
          ...(payload.meta || {}),
          starred: newStarredState,
          updatedAt: Date.now(),
        };

        try {
          localStorage.setItem(buildDeckKey(deck.id), JSON.stringify(payload));
          renderDeckShelf();
          showToast(newStarredState ? '‚òÖ Added to favorites' : 'Removed from favorites', 'success');
        } catch (error) {
          showToast('Unable to update deck', 'error');
        }
      }

      function getDeckPayload(deckId) {
        try {
          return safeParse(localStorage.getItem(buildDeckKey(deckId)));
        } catch (error) {
          console.warn('Unable to read deck payload', error);
          return null;
        }
      }

      // safeParse() and deriveDeckName() imported from utils.js

      function openDeck(deckId) {
        if (!deckId) {
          window.location.href = 'deck.html';
          return;
        }
        // Handle built-in decks with slides parameter
        if (deckId === 'design-resources') {
          window.location.href = 'deck.html#slides=design-resources';
          return;
        }
        if (deckId === 'demo-deck') {
          window.location.href = 'deck.html#slides=demo-deck';
          return;
        }
        // Use hash format to match deck.html's hash-based routing
        window.location.href = `deck.html#deck=${encodeURIComponent(deckId)}`;
      }

      function buildDeckKey(deckId) {
        return `${DECK_STORAGE_PREFIX}${encodeURIComponent(deckId)}`;
      }

      function getLastDeckId() {
        try {
          return localStorage.getItem(LAST_DECK_KEY) || '';
        } catch (error) {
          return '';
        }
      }

      function generateDeckId() {
        if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {
          return `deck-${crypto.randomUUID()}`;
        }
        const randomPart = Math.random().toString(36).slice(2, 8);
        return `deck-${Date.now().toString(36)}-${randomPart}`;
      }

      function bindPasteModal() {
        if (!pasteModal || !pasteTextarea) return;
        pasteSubmit?.addEventListener('click', handlePasteSubmit);
        pasteClosers.forEach((button) => button.addEventListener('click', closePasteModal));
      }

      function openPasteModal() {
        if (!pasteModal || pasteModal.classList.contains('is-open')) return;
        pastePreviousFocus = document.activeElement instanceof HTMLElement ? document.activeElement : null;
        pasteTextarea.value = '';
        pasteModal.classList.add('is-open');
        pasteModal.setAttribute('aria-hidden', 'false');
        requestAnimationFrame(() => pasteDialog?.focus({ preventScroll: true }));
        document.addEventListener('keydown', handlePasteKeydown, true);
      }

      function closePasteModal() {
        if (!pasteModal || !pasteModal.classList.contains('is-open')) return;
        pasteModal.classList.remove('is-open');
        pasteModal.setAttribute('aria-hidden', 'true');
        document.removeEventListener('keydown', handlePasteKeydown, true);
        const target = pastePreviousFocus && typeof pastePreviousFocus.focus === 'function'
          ? pastePreviousFocus
          : null;
        pastePreviousFocus = null;
        requestAnimationFrame(() => target?.focus());
      }

      function handlePasteSubmit() {
        const raw = pasteTextarea?.value?.trim();
        if (!raw) {
          showToast('Paste a deck JSON export first.', 'error');
          return;
        }
        let parsed;
        try {
          parsed = JSON.parse(raw);
        } catch (error) {
          showToast('That is not valid JSON. Try again.', 'error');
          return;
        }

        // Extract slides array from parsed data
        const slides = Array.isArray(parsed)
          ? parsed
          : Array.isArray(parsed?.slides)
          ? parsed.slides
          : null;

        if (!slides || slides.length === 0) {
          showToast('JSON must contain slides.', 'error');
          return;
        }

        // Generate a new deck ID and save to localStorage
        const deckId = generateDeckId();
        const payload = {
          version: 1,
          updatedAt: Date.now(),
          source: 'paste',
          slides,
          meta: {
            name: deriveDeckName(slides),
            updatedAt: Date.now(),
            deckId: deckId
          }
        };

        try {
          localStorage.setItem(buildDeckKey(deckId), JSON.stringify(payload));
          showToast(`Imported ${slides.length} slides`, 'success');
        } catch (error) {
          showToast('Unable to save. Storage may be full.', 'error');
          return;
        }

        // Navigate to the new deck using hash format
        window.location.href = `deck.html#deck=${encodeURIComponent(deckId)}&open=edit`;
      }

      function handlePasteKeydown(event) {
        if (event.key === 'Escape') {
          event.preventDefault();
          closePasteModal();
          return;
        }
        if (event.key !== 'Tab' || !pasteDialog) return;
        const focusable = pasteDialog.querySelectorAll(
          'a[href], button:not([disabled]), textarea, input:not([disabled]):not([type="hidden"]), select:not([disabled]), [tabindex]:not([tabindex="-1"])'
        );
        if (focusable.length === 0) {
          event.preventDefault();
          pasteDialog.focus({ preventScroll: true });
          return;
        }

        const first = focusable[0];
        const last = focusable[focusable.length - 1];
        if (!event.shiftKey && document.activeElement === last) {
          event.preventDefault();
          first.focus();
        } else if (event.shiftKey && document.activeElement === first) {
          event.preventDefault();
          last.focus();
        }
      }

      function bindFooterActions() {
        actionButtons.forEach((button) => {
          button.addEventListener('click', () => {
            const intent = button.dataset.openIntent;
            // Use hash format if there's an intent parameter
            const hash = intent ? `#open=${encodeURIComponent(intent)}` : '';
            window.location.href = `deck.html${hash}`;
          });
        });
      }

      function bindAboutModal() {
        aboutOpeners.forEach((button) => button.addEventListener('click', openAboutModal));
        aboutClosers?.forEach((button) => button.addEventListener('click', closeAboutModal));
      }

      function openAboutModal() {
        if (!aboutModal || aboutModal.classList.contains('is-open')) return;
        aboutPreviousFocus = document.activeElement instanceof HTMLElement ? document.activeElement : null;
        aboutModal.classList.add('is-open');
        aboutModal.setAttribute('aria-hidden', 'false');
        requestAnimationFrame(() => aboutDialog?.focus({ preventScroll: true }));
        document.addEventListener('keydown', handleAboutKeydown, true);
      }

      function closeAboutModal() {
        if (!aboutModal || !aboutModal.classList.contains('is-open')) return;
        aboutModal.classList.remove('is-open');
        aboutModal.setAttribute('aria-hidden', 'true');
        document.removeEventListener('keydown', handleAboutKeydown, true);
        const target = aboutPreviousFocus && typeof aboutPreviousFocus.focus === 'function'
          ? aboutPreviousFocus
          : null;
        aboutPreviousFocus = null;
        requestAnimationFrame(() => target?.focus());
      }

      function handleAboutKeydown(event) {
        if (event.key === 'Escape') {
          event.preventDefault();
          closeAboutModal();
          return;
        }
        if (event.key !== 'Tab' || !aboutDialog) return;
        const focusable = aboutDialog.querySelectorAll(
          'a[href], button:not([disabled]), textarea, input:not([disabled]):not([type="hidden"]), select:not([disabled]), [tabindex]:not([tabindex="-1"])'
        );
        if (focusable.length === 0) {
          event.preventDefault();
          aboutDialog.focus({ preventScroll: true });
          return;
        }

        const first = focusable[0];
        const last = focusable[focusable.length - 1];
        if (!event.shiftKey && document.activeElement === last) {
          event.preventDefault();
          first.focus();
        } else if (event.shiftKey && document.activeElement === first) {
          event.preventDefault();
          last.focus();
        }
      }
    </script>
  </body>
</html>
